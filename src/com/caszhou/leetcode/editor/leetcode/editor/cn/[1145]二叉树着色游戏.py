# æœ‰ä¸¤ä½æå®¢ç©å®¶å‚ä¸äº†ä¸€åœºã€ŒäºŒå‰æ ‘ç€è‰²ã€çš„æ¸¸æˆã€‚æ¸¸æˆä¸­ï¼Œç»™å‡ºäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ rootï¼Œæ ‘ä¸Šæ€»å…±æœ‰ n ä¸ªèŠ‚ç‚¹ï¼Œä¸” n ä¸ºå¥‡æ•°ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹ä¸Šçš„å€¼ä» 1 åˆ° 
# n å„ä¸ç›¸åŒã€‚ 
# 
#  
# 
#  æ¸¸æˆä»ã€Œä¸€å·ã€ç©å®¶å¼€å§‹ï¼ˆã€Œä¸€å·ã€ç©å®¶ä¸ºçº¢è‰²ï¼Œã€ŒäºŒå·ã€ç©å®¶ä¸ºè“è‰²ï¼‰ï¼Œæœ€å¼€å§‹æ—¶ï¼Œ 
# 
#  ã€Œä¸€å·ã€ç©å®¶ä» [1, n] ä¸­å–ä¸€ä¸ªå€¼ xï¼ˆ1 <= x <= nï¼‰ï¼› 
# 
#  ã€ŒäºŒå·ã€ç©å®¶ä¹Ÿä» [1, n] ä¸­å–ä¸€ä¸ªå€¼ yï¼ˆ1 <= y <= nï¼‰ä¸” y != xã€‚ 
# 
#  ã€Œä¸€å·ã€ç©å®¶ç»™å€¼ä¸º x çš„èŠ‚ç‚¹æŸ“ä¸Šçº¢è‰²ï¼Œè€Œã€ŒäºŒå·ã€ç©å®¶ç»™å€¼ä¸º y çš„èŠ‚ç‚¹æŸ“ä¸Šè“è‰²ã€‚ 
# 
#  
# 
#  ä¹‹åä¸¤ä½ç©å®¶è½®æµè¿›è¡Œæ“ä½œï¼Œæ¯ä¸€å›åˆï¼Œç©å®¶é€‰æ‹©ä¸€ä¸ªä»–ä¹‹å‰æ¶‚å¥½é¢œè‰²çš„èŠ‚ç‚¹ï¼Œå°†æ‰€é€‰èŠ‚ç‚¹ä¸€ä¸ª æœªç€è‰² çš„é‚»èŠ‚ç‚¹ï¼ˆå³å·¦å³å­èŠ‚ç‚¹ã€æˆ–çˆ¶èŠ‚ç‚¹ï¼‰è¿›è¡ŒæŸ“è‰²ã€‚ 
# 
#  å¦‚æœå½“å‰ç©å®¶æ— æ³•æ‰¾åˆ°è¿™æ ·çš„èŠ‚ç‚¹æ¥æŸ“è‰²æ—¶ï¼Œä»–çš„å›åˆå°±ä¼šè¢«è·³è¿‡ã€‚ 
# 
#  è‹¥ä¸¤ä¸ªç©å®¶éƒ½æ²¡æœ‰å¯ä»¥æŸ“è‰²çš„èŠ‚ç‚¹æ—¶ï¼Œæ¸¸æˆç»“æŸã€‚ç€è‰²èŠ‚ç‚¹æœ€å¤šçš„é‚£ä½ç©å®¶è·å¾—èƒœåˆ© âœŒï¸ã€‚ 
# 
#  
# 
#  ç°åœ¨ï¼Œå‡è®¾ä½ æ˜¯ã€ŒäºŒå·ã€ç©å®¶ï¼Œæ ¹æ®æ‰€ç»™å‡ºçš„è¾“å…¥ï¼Œå‡å¦‚å­˜åœ¨ä¸€ä¸ª y å€¼å¯ä»¥ç¡®ä¿ä½ èµ¢å¾—è¿™åœºæ¸¸æˆï¼Œåˆ™è¿”å› trueï¼›è‹¥æ— æ³•è·èƒœï¼Œå°±è¯·è¿”å› falseã€‚ 
# 
#  
# 
#  ç¤ºä¾‹ï¼š 
# 
#  
# 
#  è¾“å…¥ï¼šroot = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3
# è¾“å‡ºï¼šTrue
# è§£é‡Šï¼šç¬¬äºŒä¸ªç©å®¶å¯ä»¥é€‰æ‹©å€¼ä¸º 2 çš„èŠ‚ç‚¹ã€‚
#  
# 
#  
# 
#  æç¤ºï¼š 
# 
#  
#  äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ä¸º rootï¼Œæ ‘ä¸Šç”± n ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹ä¸Šçš„å€¼ä» 1 åˆ° n å„ä¸ç›¸åŒã€‚ 
#  n ä¸ºå¥‡æ•°ã€‚ 
#  1 <= x <= n <= 100 
#  
#  Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æ ‘ ğŸ‘ 68 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
import math


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def btreeGameWinningMove(self, root, n, x):
        # root = self.ary_to_tree_node(ary, 0, False)

        x_root = self.find_node(root, x)
        half = math.floor(n / 2)

        if x_root is not None:
            left_size = self.count_nodes(x_root.left)
            right_size = self.count_nodes(x_root.right)
            return left_size > half or right_size > half or left_size + right_size < half

        return False
    #
    # def ary_to_tree_node(self, ary, level, right):
    #     if right:
    #         root = TreeNode(ary[2 ^ level])
    #     else:
    #         root = TreeNode(ary[2 ^ level - 1])
    #     level += 1
    #
    #     if len(ary) > 1:
    #         root.left = self.ary_to_tree_node(ary, level, False)
    #
    #     if len(ary) > 2:
    #         root.right = self.ary_to_tree_node(ary, level, True)
    #
    #     return root

    def find_node(self, root, x):
        if root is None:
            return None

        if root.val == x:
            return root

        left = self.find_node(root.left, x)
        right = self.find_node(root.right, x)
        return left if left is not None else right

    def count_nodes(self, node):
        if node is None:
            return 0
        return self.count_nodes(node.left) + self.count_nodes(node.right) + 1
# leetcode submit region end(Prohibit modification and deletion)
